
import java.util.Random;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class RandomLinkedQueue<Item> implements Iterable<Item> {

    private Node start;
    private Node end;
    private Random rand;
    private int size;

    /**
     * This constructor initalizes only my Random Object and explicilty sets my
     * inital size to 0 to create an empty linked list
     * 
     */
    public RandomLinkedQueue() {

        this.size = 0;
        this.rand = new Random();
    }

    /**
     * This inner class is used to create all the nodes within my linked-list that
     * manages my random queue
     * 
     */
    private class Node {

        private Node next;
        private Item content;
    }

    /**
     * This method is used to create new random and valid index within my
     * linked-list
     * 
     * @return a random integer that is between 0 and my linked-list's size - 1
     * 
     */
    private int newIndex() {

        return rand.nextInt(size());
    }

    /**
     * Simply checks to see if the linked-list is empty by checking it's length
     * 
     * @return a boolean by comparing the linked-list's current size to 0
     * 
     */
    public boolean isEmpty() {

        return this.size == 0;
    }

    /**
     * Checks the linked-list's current size
     * 
     * @return the current number of node objects
     * 
     */
    public int size() {

        return this.size;
    }

    /**
     * This method adds on a new node to the linked-list; setting the same new
     * node's content as well
     * 
     * @param newContent this is the new information added to the linked-list
     */
    public void enqueue(Item newContent) {
        Node newNode = new Node();
        newNode.content = newContent;

        if (isEmpty()) {

            start = newNode;
            end = newNode;
        } else {

            end.next = newNode;
            end = newNode;
        }
        size++;
    }

    /**
     * This method is what makes this a RandomQueue; when called a new random index
     * is created.
     * 
     * This index is first checked to see if it is the start of the queue, if it is
     * then we can set the head to the second node (this is best time case). If it
     * is not the start then the queue is looped through. When the index is reached
     * the node previous to the current node it is then pointed to the node next of
     * the current node.
     * 
     * @return the content of the node matching the index generated by newIndex()
     * 
     */
    public Item dequeue() {

        Item returnItem;
        Node lastNode = this.start;
        int index = newIndex();
        if (index == 0) {

            returnItem = this.start.content;
            this.start = this.start.next;
            size--;
            return returnItem;
        } else if (index == size()) {

            returnItem = this.end.content;
            this.end = lastNode;
            size--;
            return returnItem;
        }

        for (int i = 1; i < size; i++) {

            if (index == i) {

                returnItem = lastNode.next.content;
                lastNode.next = lastNode.next.next;
                size--;
                return returnItem;
            }

            lastNode = lastNode.next;
        }

        throw new NoSuchElementException();
    }

    /**
     * This method acts similarly to dequeue execpt that the node is not removed
     * from the linked-list
     * 
     * @return the content of the node matching the index generated by newIndex()
     * 
     */
    public Item sample() {

        int index = newIndex();
        Node current = this.start;
        for (int i = 0; i < size; i++) {

            if (index == i) {
                return current.content;
            }
            current = current.next;
        }
        throw new NoSuchElementException();
    }

    /**
     * 
     * This is the iterator and I have issues with this; I cannot get the for loop
     * to work when only one element in the list exists
     * 
     */
    @Override
    public Iterator<Item> iterator() {

        return new Iterator<Item>() {
            int check = 0;

            @Override
            public boolean hasNext() {
                if (start != null) {

                    return start.next != null;
                }
                return false;
            }

            @Override
            public Item next() {

                if (check == 0) {

                    check++;
                    return start.content;
                } else if (start != null) {

                    start = start.next;
                    return start.content;
                }
                throw new NoSuchElementException();
            }
        };
    }

    public static void main(String[] args) {

        RandomLinkedQueue<Object> Queue = new RandomLinkedQueue<Object>();

        Queue.enqueue(280);
        Queue.enqueue("Random Queue Testing");
        Queue.enqueue(7.2);
        Queue.enqueue("Finnegan");
        Queue.enqueue("JAYNE");

        System.out.println("\nThis is the dequeue that will be removed from the list: " + Queue.dequeue() + "\n");
        System.out.println("\nThis is the dequeue that will be removed from the list: " + Queue.dequeue() + "\n");
        System.out.println("\nThis is the dequeue that will be removed from the list: " + Queue.dequeue() + "\n");
        System.out.println("\nThis is the dequeue that will be removed from the list: " + Queue.dequeue() + "\n");
        System.out.println("This is the sample that will stay in the list: " + Queue.sample() + "\n");

        for (Object i : Queue) {

            System.out.println(i);
        }

    }

}